# Lab 2 Introduction to communication 
> It is mandetory to prepare your documents in `Markdown` format. We prepared an example repository in [Lab Report Sample](https://github.com/efrei-paris-sud/2019-sample-project/tree/master/lab/1). 
> All needed codes described in this repository. For more details about markdown please visit the [Example Report](https://github.com/efrei-paris-sud/2019-sample-project/tree/master/lab/1/report/1)

Put all reports into `lab/2/` folder in your repository. 
## Fritzing
The software is created in the spirit of the Processing programming language and the Arduino microcontroller[4] and allows a designer, artist, researcher, or hobbyist to document their Arduino-based prototype and create a PCB layout for manufacturing. 

- [Download Fritzing](https://github.com/fritzing/fritzing-app/releases/tag/CD-268)
- Create a new `sketch`.
- Search for `NodeMCU-32S` fritzing part and add it to Fritzing.
Note: please insure that the pin maps of the part is as same as the image in Lab 1.
- Create a random sketch your self (at least 5 component is needed and please don't forget connect them and use different colors in wiring)
-- Export the result as image(`lab/2/report/1/sketch.png`)
- Design the Schematic of that. Please style it in a good format.
-- Export the result as image(`lab/2/report/1/schematic.png`)
- Make a (`lab/2/report/1/README.md`) file and put a the images and a small description on it and **USE MARKDOWN FORMAT PLEASE**. For images please use the uploaded images from your `github`.
[Example Report](https://github.com/efrei-paris-sud/2019-sample-project/tree/master/lab/1/report/1)

# Communication 
In this lab, we will learn how the I2C/SPI/Serial communication protocol works.
## Serial 
The Wiring Serial serial port allows for easily reading and writing data to and from external devices. It allows two machines to communicate and gives you the flexibility to make your own devices and use them as the input or output to your Wiring programs.

The serial communication is very good for debuging your code. You can connect your arduino board to your computer easily. It works like a simple console. Let's start to use it.

In the Setup function we should define the Serial comunication. 
```C
void setup() {
  Serial.begin(9600);  // Start serial Serial at 9600 baud
}
```
> It is important that both devices have the same baud rate (transmission speed). [more info](https://fr.wikipedia.org/wiki/UART)
> You should change the baud rate in your client to read the data correctly.

To send data to the other device we can easily use. It will print `string`.
```C
Serial.print("string");
```
To read data from other device, we can use following code.
```C
byte b = Serial.read();
```
For more information click [here](http://wiring.org.co/reference/Serial.html)

A simple program:
```C
void setup() {
  // initialize serial:
  Serial.begin(9600);
  ....
}

void loop() {
  // if there's any serial available, read it:
  while (Serial.available() > 0) {

    // look for the next valid integer in the incoming serial stream:
    int i  = Serial.parseInt();
    // look for the next valid byte in the incoming serial stream:
    byte b = Serial.read();
    // look for the newline. That's the end of your sentence:
    if (Serial.read() == '\n') 
      .....
      
    // print the three numbers in one string as hexadecimal:
    Serial.print(15, HEX);//print F
    Serial.print(10, DEC);//Print 10
    Serial.println("Hello"); //Print Hello\n
    
  }
}
```

You can also connect 2 devices with serial communication. Please don't forget to connect TX from one side to RX in another side.

![serial communication](https://cdn.sparkfun.com/assets/2/5/c/4/5/50e1ce8bce395fb62b000000.png)

### Practic 2:
- Develop an arduino program which can read a byte from serial  and adjust the passive buzzer frequency with that. Write a response that your buzzer frequency changed to the read value. (`lab/2/report/2/code.ino`).
- Create a Fritzing sketch and export it on(`lab/2/report/2/sketch.png`).
- Connect your Arduino board to computer. Open a serial communication software (You can use built in serial monitor in Arduino IDE by pressing `ctrl`+`shift`+`M` or any other softwares like [Putty](https://www.putty.org/))
- Write a short report on (lab/2/report/2/README.md)

## I2C
I2C is a serial protocol for two-wire interface to connect low-speed devices.

Each device has a preset ID or a unique device address so the master can choose with which devices will be communicating. So many devices can communicate together with only 2 wires!

The two wires, or lines are called Serial Clock (or SCL) and Serial Data (or SDA).  The SCL line is the clock signal which synchronize the data transfer between the devices on the I2C bus and it’s generated by the master device. The other line is the SDA line which carries the data.

![I2C](https://www.analog.com/-/media/analog/en/landing-pages/technical-articles/i2c-primer-what-is-i2c-part-1-/36684.png?la=en&w=900)

The two lines are “open-drain” which means that pull up resistors needs to be attached to them so that the lines are high because the devices on the I2C bus are active low. Commonly used values for the resistors are from 2K for higher speeds at about 400 kbps, to 10K for lower speed at about 100 kbps. [More info on I2C](https://howtomechatronics.com/tutorials/arduino/how-i2c-communication-works-and-how-to-use-it-with-arduino/)

> BME 280 
> The GY-BME280 is a high precision combined digital pressure, humidity and temperature sensor module with I2C and SPI interfaces.
> ![BME 280](https://protosupplies.com/wp-content/uploads/2019/02/GY-BME280-Humidity-Pressure-Temperature-Sensor-Module-Connections.jpg)


Connect your arduino to bme280 using following sketch.
- VCC -> 5V
- GNF -> GND
- SCL -> A5
- SDA -> A4
![connect](http://static.cactus.io/img/hookups/arduino/connect-arduino-to-bme280-i2c-sensor.jpg)

To add BMP280 Library goto `Tools` -> `Library Manager` -> search for `BMP280`
Please use the example from [BMP280 Example](https://github.com/adafruit/Adafruit_BMP280_Library/tree/master/examples/bmp280test).

- Upload the code on(`lab/2/report/3/code.ino`).
- Create a Fritzing sketch and export it on (`lab/2/report/3/sketch.png`).
- Take a photo from your board (`lab/2/report/3/photo.png`).
- Write a short report on (`lab/2/report/3/README.md`)


## SPI
Please follow the tutorial from  [SPI](https://circuitdigest.com/microcontroller-projects/arduino-spi-communication-tutorial)

Instead using 2 Arduino Uno, We will use one Arduino Uno and one ESP32.
- Find `MISO` `MOSI` `SCK` `SSS` in the pin maps from last TP's Readme file for both ESP32 and Arduino Uno.
- Create a Fritzing sketch and export it on (`lab/2/report/4/sketch.png`).
- Assume arduino as Slave and esp32 as Master.
- Upload the code on(`lab/2/report/4/arduino.ino`, `lab/2/report/4/esp32.ino`).
- Take a photo from your board (`lab/2/report/4/photo.png`).
- Write a short report on how it works in (`lab/2/report/4/README.md`)


## SPI vs I2C
- I2C requires only two wires, while SPI requires three or four.
- SPI supports higher speed full-duplex communication while I2C is slower.
- I2C draws more power than SPI.
- I2C supports multiple devices on the same bus without additional select signal lines through in-communication device addressing while SPI requires additional signal lines to manage multiple devices on the same bus.
- I2C ensures that data sent is received by the slave device while SPI does not verify that data is received correctly.
- I2C can be locked up by one device that fails to release the communication bus.
- SPI cannot transmit off the PCB while I2C can, albeit at low data transmission speeds.
- I2C is cheaper to implement than the SPI communication protocol.
- SPI only supports one master device on the bus while I2C supports multiple master devices.
- I2C is less susceptible to noise than SPI.
- SPI can only travel short distances and rarely off of the PCB while I2C can transmit data over much greater distances, although at low data rates.
- The lack of a formal standard has resulted in several variations of the SPI protocol, variations which have been largely avoided with the I2C protocol.
